CLEAN SLATE DESIGN

Ultimately we need the offsets for any source P4 program's fields represented in HP4's extracted.data field.  In support of this goal we need to ensure that the final time HP4 exits the setup control function, it has identified the path taken through the parser, corresponding to the parse control state.

OBJECTIVE 1: determine all steps necessary to generate tset_control table entries
(Later objectives will handle tset_inspect_XX_YY entries and other tables in setup.p4.)

HP4's task is to apply tset_control for every pc.state to determine whether to extract more, inspect extracted bytes, or proceed to ingress.

A pc.state corresponds to a path segment in the parse tree of the source P4.  A path segment starts at 'start' or immediately following a conditional jump (from a select statement).  It terminates either at an unconditional jump to ingress, or at a conditional jump (i.e., select statement).  Note a pc.state is not the same thing as a parse_state (HLIR's term for a parse function in the source P4 program).

We refer to the jump to ingress (action: PROCEED) or to the select statement (action: INSPECT_XX_YY) as the path segment terminator.

So pc.state == 0 corresponds to the initial state of HP4 after a packet has been received.  We can reserve pc.state == 1 to the state of HP4 when prepared to carry out the inital path segment terminator.  Whether the action in tset_control [action] [program ID] 0 => [numbytes | next_action] 1 is extract_more or set_next_action, the action's state parameter should always be 1.

The number of pc.states should be upper bounded by 1 + the total number of entries across all select statements.

Remember that the tset_inspect_XX_YY table handling the select statement is responsible for extracting more bytes and updating the pc.state, so that by the time HP4 applies tset_control again, pc.state will be updated and enough bytes will have been extracted to handle the next path segment terminator.

action set_next_action(next_action, state) {
  modify_field(parse_ctrl.next_action, next_action);
  modify_field(parse_ctrl.state, state);
}

action extract_more(numbytes, state) {
  modify_field(parse_ctrl.numbytes, numbytes);
  modify_field(parse_ctrl.next_action, EXTRACT_MORE);
  modify_field(parse_ctrl.state, state);
  resubmit(fl_extract_more);
}

table tset_control {
  reads {
    meta_ctrl.program : exact;
    parse_ctrl.numbytes : exact;
    parse_ctrl.state : exact;
  }
  actions {
    set_next_action;
    set_next_action_chg_program;
    extract_more;
    extract_more_chg_program;
  }
}

Ignore set_next_action_chg_program and extract_more_chg_program for now.

bits_extracted (dictionary):
- key: (integer) pc.state
- value: (integer) number of bytes we can assume have been extracted once we are in the pc.state

bits_needed_local (dictionary):
- key: parse_state
- value: numbits

bits_needed_total (dictionary):
- key: (parse_state, list of preceding states)
- value: numbits

field_offsets (dictionary):
- key: (integer) pc.state
- value: (integer) offset

We have bits_extracted[0] = args.SEB, always.  HP4C traverses the parse tree until the first terminator, having populated bits_needed_total such that we have an entry for the key consisting of the terminator's parse_state and all preceding parse_states.  Then HP4C can determine the first tset_control entry to issue: extract_more or set_next_action (for a PROCEED or INSPECT_XX_YY as appropriate).

HP4C First Task: Go through the parse tree of the source P4 and identify all path segments, i.e., pc.states, their byte requirements, and their terminators.  For conditional jump terminators, identify the byte range to inspect to properly handle the select statement.

A. Identify all path segments, i.e., pc.states:
   We have the key set from bits_needed_total: tuples in the form (parse_state, list of preceding parse_states).  For each key, we can traverse the list of preceding parse_states until we encounter a terminator (return to ingress or return select).
  I don't know about this...

  TODO: FINISH THIS OFF - THIS IS LOOKING GOOD SO FAR:
  Start at pc.state = 0, (parse_state) ps = p4_parse_states['start'], currbits_prev = 0, (global integer) next_pc_state = 2
  func( (integer) pc.state, (parse_state) ps, (integer) currbits_prev):
    bits_extracted[pc.state] = bits_needed_local[ps] - currbits_prev.
    currbits_prev = bits required by any 'current' calls
    if ps' return statement == Unconditional jump to ingress:
      issue tset_control set_next_action [program ID] [pc.state] => [PROCEED] [pc.state]
      return
    elif ps' return statement == Unconditional jump to another parse_state:
      update ps (but not pc.state) and recurse
    else ps' return statement == Conditional jump:
      issue tset_control set_next_action [program ID] [pc.state] => [INSPECT_XX_YY] [pc.state]
      issue tset_inspect_XX_YY
      for each branch:
        if branch target == another parse_state:
          ps = target
          pc.state = next_pc_state
          next_pc_state += 1
          recurse
        elif branch target == ingress:

HP4C Second Task: Issue tset_control entries for each path segment:
- pc.state == 0:
  if args.SEB < bits_needed_total[0] / if bits_extracted[0] < bits_needed_total[0, ()]:
    tset_control extract_more "[program ID]" [pc.state] => [bits_needed_total[0]] 1
  else:
    terminator == unconditional jump to ingress
      tset_control set_next_action "[program ID]" [pc.state] => "[PROCEED]" [pc.state]
    terminator == conditional jump
      tset_control set_next_action "[program ID]" [pc.state] => "[INSPECT_XX_YY]" [pc.state]
- else:
  - terminator == unconditional jump to ingress
      tset_control set_next_action "[program ID]" [pc.state] => "[PROCEED]" [pc.state]
  - terminator == conditional jump
      tset_control set_next_action "[program ID]" [pc.state] => "[INSPECT_XX_YY]" [pc.state]

PROBABLY OBSOLETE TEXT FOLLOWS:

HP4 does a resubmit for every parse_state that requires more bytes than what have previously been extracted.

For parse_ctrl.state == 0 ('start'), the question is whether the combined usage of 'current' and 'select' statements (bits_needed_total) require more than the SEB number of bytes.

For all other parse_ctrl.states, we should assume the required number of bytes have already been extracted.  An extract_more comes from one of two things:
  1. a tset_inspect_XX_YY result that identifies the next parse_ctrl.state to transition to, and it requires more bytes than have been extracted.  We extract what is required and update the parse_ctrl.state.
  2. an unconditional return statement referencing another parse_state that requires more bytes.  We extract what is required and update the parse_ctrl.state.  This doesn't quite get it though - we haven't expressed what is happening in terms of HP4 but rather the target program.  For HP4, unconditional jumps to other parse_states that require more bytes should be consolidated by the compiler and extracted either from the beginning or in response to a tset_inspect_XX_YY.

A set_next_action comes from:
  The need to carry out a tset_inspect_XX_YY (i.e., we are in a parse_state after having extracted everything necessary and now we need to handle a select statement).
  An unconditional return statement referencing another parse_state that does not require more bytes.
  An unconditional return to ingress.
  A tset_inspect_XX_YY that identifies the next parse_ctrl.state to transition to, and it does not require more bytes than have been extracted.

[reminder]
table_add tset_control <set_next_action | extract_more> [program ID] <numbytes> <parse_ctrl.state> => <APARAMS>

Let's look at the parse_ctrl.state associated with the 'start' parse_state first.
# NOTE: this question can be more generically applied by asking whether
  the number of bits needed in the next parse_state yet to be entered is
  greater than what we've already extracted.
  This implies we should consider pc.state == 0 as the state prior to
  entering the 'start' node (parseControlStates key value: (NULL, []).
  We make a state transition once we've checked the requirement.
- Is the bits_needed_total[('start', [])] > args.SEB?
  -- yes:
     we need two table entries.  One with MPARAMS numbytes == 0, the other
     with MPARAMS numbytes = bits_needed_total[('start'), [])].
     #1:
     ACTION: extract_more
     MPARAMS:
       numbytes: 0
       parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
     APARAMS:
       numbytes: bits_needed_total[('start', [])]
       state: parseControlStates[('start', [])] (i.e., don't change)
     #2:
     Continue as if bits_needed_total[('start', [])] <= args.SEB
  -- no:
     Does the return statement include a select statement?
     --- yes
         ACTION: set_next_action
         MPARAMS:
           numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
           parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
         APARAMS:
           next_action: INSPECT_XX_YY <-- replace as appropriate after looking at field_offsets
           state: parseControlStates[('start', [])] (i.e., don't change)
     --- no
         Does the return statement go straight to ingress?
         ---- yes:
              ACTION: set_next_action
              MPARAMS:
                numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
                parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
              APARAMS:
                next_action: [PROCEED]
                state: parseControlStates[('start', [])] (i.e., don't change)
         ---- no:
              get the next_state
              bits_needed_total[('start', [])] < bits_needed_total[(next_state, ['start'])]?
              ----- yes:
                    ACTION: extract_more
                    MPARAMS:
                      numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
                      parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
                    APARAMS:
                      numbytes: bits_needed_total[(next_state, ['start'])]
                      state: parseControlStates[(next_state, ['start'])]
              ----- no:
                    set_next_action
                    ???
