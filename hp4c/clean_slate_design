CLEAN SLATE DESIGN

Objective: determine all steps necessary to generate tset_control table entries

action set_next_action(next_action, state) {
  modify_field(parse_ctrl.next_action, next_action);
  modify_field(parse_ctrl.state, state);
}

action extract_more(numbytes, state) {
  modify_field(parse_ctrl.numbytes, numbytes);
  modify_field(parse_ctrl.next_action, EXTRACT_MORE);
  modify_field(parse_ctrl.state, state);
  resubmit(fl_extract_more);
}

table tset_control {
  reads {
    meta_ctrl.program : exact;
    parse_ctrl.numbytes : exact;
    parse_ctrl.state : exact;
  }
  actions {
    set_next_action;
    set_next_action_chg_program;
    extract_more;
    extract_more_chg_program;
  }
}

Ignore set_next_action_chg_program and extract_more_chg_program for now.

parse_ctrl.state: an integer corresponding to a (current, list of preceding states) tuple.  It identifies a unique path through the parse tree from the start parse_state to the current parse_state.

parseControlStates (dictionary):
- key:   tuple   - (parse_state, list of preceding states)
- value: integer - parse_ctrl.state

bits_needed_local (dictionary):
- key: parse_state
- value: numbits

bits_needed_total (dictionary):
- key: (parse_state, list of preceding states)
- value: numbits

field_offsets (dictionary):
- key: (field name (string), parse_ctrl.state (integer))
- value: offset (integer)

1. set_next_action | extract_more ...

HP4 does a resubmit for every parse_state that requires more bytes than what have previously been extracted.

For parse_ctrl.state == 0 ('start'), the question is whether the combined usage of 'current' and 'select' statements (bits_needed_total) require more than the SEB number of bytes.

For all other parse_ctrl.states, we should assume the required number of bytes have already been extracted.  An extract_more comes from one of two things:
  1. a tset_inspect_XX_YY result that identifies the next parse_ctrl.state to transition to, and it requires more bytes than have been extracted.  We extract what is required and update the parse_ctrl.state.
  2. an unconditional return statement referencing another parse_state that requires more bytes.  We extract what is required and update the parse_ctrl.state.
A set_next_action comes from:
  The need to carry out a tset_inspect_XX_YY (i.e., we are in a parse_state after having extracted everything necessary and now we need to handle a select statement).
  An unconditional return statement referencing another parse_state that does not require more bytes.
  An unconditional return to ingress.
  A tset_inspect_XX_YY that identifies the next parse_ctrl.state to transition to, and it does not require more bytes than have been extracted.

[reminder]
table_add tset_control <set_next_action | extract_more> [program ID] <numbytes> <parse_ctrl.state> => <APARAMS>

Let's look at the parse_ctrl.state associated with the 'start' parse_state first.
# NOTE: this question can be more generically applied by asking whether
  the number of bits needed in the next parse_state yet to be entered is
  greater than what we've already extracted.
  This implies we should consider pc.state == 0 as the state prior to
  entering the 'start' node (parseControlStates key value: (NULL, []).
  We make a state transition once we've checked the requirement.
- Is the bits_needed_total[('start', [])] > args.SEB?
  -- yes:
     we need two table entries.  One with MPARAMS numbytes == 0, the other
     with MPARAMS numbytes = bits_needed_total[('start'), [])].
     #1:
     ACTION: extract_more
     MPARAMS:
       numbytes: 0
       parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
     APARAMS:
       numbytes: bits_needed_total[('start', [])]
       state: parseControlStates[('start', [])] (i.e., don't change)
     #2:
     Continue as if bits_needed_total[('start', [])] <= args.SEB
  -- no:
     Does the return statement include a select statement?
     --- yes
         ACTION: set_next_action
         MPARAMS:
           numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
           parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
         APARAMS:
           next_action: INSPECT_XX_YY <-- replace as appropriate after looking at field_offsets
           state: parseControlStates[('start', [])] (i.e., don't change)
     --- no
         Does the return statement go straight to ingress?
         ---- yes:
              ACTION: set_next_action
              MPARAMS:
                numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
                parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
              APARAMS:
                next_action: [PROCEED]
                state: parseControlStates[('start', [])] (i.e., don't change)
         ---- no:
              get the next_state
              bits_needed_total[('start', [])] < bits_needed_total[(next_state, ['start'])]?
              ----- yes:
                    ACTION: extract_more
                    MPARAMS:
                      numbytes: bits_needed_total[('start', [])] (i.e., 0 for this case)
                      parse_ctrl.state: parseControlStates[('start', [])] (i.e., 0 for this case)
                    APARAMS:
                      numbytes: bits_needed_total[(next_state, ['start'])]
                      state: parseControlStates[(next_state, ['start'])]
              ----- no:
                    set_next_action
                    ???
