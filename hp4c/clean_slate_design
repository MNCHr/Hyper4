CLEAN SLATE DESIGN

Objective: determine all steps necessary to generate tset_control table entries

action set_next_action(next_action, state) {
  modify_field(parse_ctrl.next_action, next_action);
  modify_field(parse_ctrl.state, state);
}

action extract_more(numbytes) {
  modify_field(parse_ctrl.numbytes, numbytes);
  modify_field(parse_ctrl.next_action, EXTRACT_MORE);
  resubmit(fl_extract_more);
}

table tset_control {
  reads {
    meta_ctrl.program : exact;
    parse_ctrl.numbytes : exact;
    parse_ctrl.state : exact;
  }
  actions {
    set_next_action;
    set_next_action_chg_program;
    extract_more;
    extract_more_chg_program;
  }
}

Ignore set_next_action_chg_program and extract_more_chg_program for now.

parse_ctrl.state: an integer corresponding to a (current, list of preceding states) tuple.  It identifies a unique path through the parse tree from the start parse_state to the current parse_state.

parseControlStateUIDs (dictionary):
- key:   tuple   - (parse_state, list of preceding states)
- value: integer - parse_ctrl.state

bits_needed_total (dictionary):
- key: (parse_state, list of preceding states)
- value: numbits

TBD (dictionary):
- key: (field name (string), parse_ctrl.state (integer))
- value: offset (integer)

1. set_next_action | extract_more ...

HP4 does a resubmit for every parse_state that requires more bytes than what have previously been extracted.

For parse_ctrl.state == 0 ('start'), the question is whether the combined usage of 'current' and 'select' statements (bits_needed_total) require more than the SEB number of bytes.

For all other parse_ctrl.states, we should assume the required number of bytes have already been extracted.  An extract_more comes from one of two things:
  1. a tset_inspect_XX_YY result that identifies the next parse_ctrl.state to transition to, and it requires more bytes than have been extracted.  We extract what is required and update the parse_ctrl.state.
  2. an unconditional return statement referencing another parse_state that requires more bytes.  We extract what is required and update the parse_ctrl.state.
A set_next_action comes from:
  The need to carry out a tset_inspect_XX_YY (i.e., we are in a parse_state after having extracted everything necessary and now we need to handle a select statement).
  An unconditional return statement referencing another parse_state that does not require more bytes.
  An unconditional return to ingress.
  A tset_inspect_XX_YY that identifies the next parse_ctrl.state to transition to, and it does not require more bytes than have been extracted.
