CLEAN SLATE DESIGN

Ultimately we need the offsets for any source P4 program's fields represented in HP4's extracted.data field.  In support of this goal we need to ensure that the final time HP4 exits the setup control function, it has identified the path taken through the parser, corresponding to the parse control state.

OBJECTIVE 1: generate tset_control table entries
(Later objectives will handle tset_inspect_XX_YY entries and other tables in setup.p4.)

HP4's task is to apply tset_control for every pc.state to determine whether to extract more, inspect extracted bytes, or proceed to ingress.

A pc.state corresponds to a path segment in the parse tree of the source P4.  A path segment starts at 'start' or immediately following a conditional jump (from a select statement).  It terminates either at an unconditional jump to ingress, or at a conditional jump (i.e., select statement).  Note a pc.state is not the same thing as a parse_state (HLIR's term for a parse function in the source P4 program).

We refer to the jump to ingress (action: PROCEED) or to the select statement (action: INSPECT_XX_YY) as the path segment terminator.

So pc.state == 0 corresponds to the initial state of HP4 after a packet has been received.  We can reserve pc.state == 1 to the state of HP4 when prepared to carry out the inital path segment terminator.  Whether the action in tset_control [action] [program ID] 0 => [numbytes | next_action] 1 is extract_more or set_next_action, the action's state parameter should always be 1.

The number of pc.states should be upper bounded by 1 + the total number of entries across all select statements.

Remember that the tset_inspect_XX_YY table handling the select statement is responsible for extracting more bytes and updating the pc.state, so that by the time HP4 applies tset_control again, pc.state will be updated and enough bytes will have been extracted to handle the next path segment terminator.

action set_next_action(next_action, state) {
  modify_field(parse_ctrl.next_action, next_action);
  modify_field(parse_ctrl.state, state);
}

action extract_more(numbytes, state) {
  modify_field(parse_ctrl.numbytes, numbytes);
  modify_field(parse_ctrl.next_action, EXTRACT_MORE);
  modify_field(parse_ctrl.state, state);
  resubmit(fl_extract_more);
}

table tset_control {
  reads {
    meta_ctrl.program : exact;
    parse_ctrl.numbytes : exact;
    parse_ctrl.state : exact;
  }
  actions {
    set_next_action;
    set_next_action_chg_program;
    extract_more;
    extract_more_chg_program;
  }
}

Ignore set_next_action_chg_program and extract_more_chg_program for now.

pc_bits_extracted (dictionary):
- key: (integer) pc.state
- value: (integer) number of bytes we can assume have been extracted once we are in the pc.state

field_offsets (dictionary):
- key: (integer) pc.state
- value: (integer) offset

There is only one case where the tset_control entry will have extract_more as the action: pc.state is 0 and the number of bytes extracted prior to the first path segment terminator is more than SEB.

We have bits_extracted[0] = args.SEB, always.  HP4C traverses the parse tree until the first terminator, having populated bits_needed_total such that we have an entry for the key consisting of the terminator's parse_state and all preceding parse_states.  Then HP4C can determine the first tset_control entry to issue: extract_more or set_next_action (for a PROCEED or INSPECT_XX_YY as appropriate).

Objective 1 Algorithm: Go through the parse tree of the source P4 and identify all path segments, i.e., pc.states, their byte requirements, and their terminators.  Each extract statement should update field_offsets and bits_extracted.  For conditional jump terminators, use field_offsets to identify the byte range to inspect to properly handle the select statement.  Also for conditional jump terminators, look for the use of 'current' and update bits_extracted accordingly.  Prior to recursing for each condition of a conditional jump terminator, update the current pc.state, and set bits_extracted to that of the previous pc.state minus any bits required by 'current'.

OBJECTIVE 2: generate tset_inspect_XX_YY entries

In most cases, tset_inspect_XX_YY matches will trigger a set_next_action: PROCEED (direct jump to ingress) or an extract_more (next parse_state requires more bytes than what have been extracted so far).  The exception is a direct jump to another parse_state that does not extract any additional bytes nor employ 'current' beyond what has been extracted, in which case the action is determined by the terminator of the next parse_state.

We need a tset_inspect_XX_YY entry for each selectopt in each conditional return statement.

Challenges:
- identifying next pc_state
  - take advantage of walk_parse_tree that already does some handling for each 'selectopt' in the conditional return statement
- producing the ternary match strings
  - take advantage of process_parse_state that already does some handling for each 'criteria' for the conditional return statement

action set_next_action(next_action, state) {
  modify_field(parse_ctrl.next_action, next_action);
  modify_field(parse_ctrl.state, state);
}

action extract_more(numbytes, state) {
  modify_field(parse_ctrl.numbytes, numbytes);
  modify_field(parse_ctrl.next_action, EXTRACT_MORE);
  modify_field(parse_ctrl.state, state);
  resubmit(fl_extract_more);
}

table tset_inspect_XX_YY {
  reads {
    meta_ctrl.program : exact;
    parse_ctrl.state: exact;
    ext[XX].data : ternary;
    // ...
    ext[YY].data : ternary;
  }
  actions {
    set_next_action;
    set_next_action_chg_program;
    extract_more;
    extract_more_chg_program;
  }
}

Ignore set_next_action_chg_program and extract_more_chg_program for now.

tset_inspect_commands (dictionary):
- key: (string) table_name
- val: [command1, command2, ...]
where each command is a list: [action, [mparams], [aparams]]

Objective 2 Algorithm: Augment algorithm for objective 1:  To walk the parse tree, we are already collecting next parse_states identified by the selectopts present where the current parse_state ends in a conditional return statement.  Each such parse_state is the start (or, in most cases, the entirety) of a pc_state.  So we will make the association explicit at the time the next parse_state is collected.  This handles the second action parameter for each entry.
