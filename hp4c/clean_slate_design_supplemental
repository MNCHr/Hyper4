For the most part, we are looking forward, at the next parseControlState (as determined by the result of a tset_inspect_XX_YY match or an unconditional return to another parse_state) and it's requirements as read from bits_needed_total, comparing to the current parseControlState and it's requirements as read from bits_needed_total.  The one exception is parse_control.state == 0, which actually has two sub states, one where parse_control.numbytes == 0 and one where it doesn't.

So we handle parse_control.state == 0 as a special case.

startkey = (self.h.p4_parse_states['start'], ())
reqd_bits = self.bits_needed_total[startkey]
curr_bits = self.args.seb
if reqd_bits > curr_bits:
  # issue extract_more entry
  self.commands.append(HP4_Command("table_add",
                                   "tset_control",
                                   "extract_more",
                                   ["[program ID]", "0", "0"],
                                   [string(reqd_bits), "0"]))

For every key in parseControlStates.keys():
  
