HyPer4 Subsystems

Ingress
- context setting
  - tset_context

  When a packet is received from a physical port, we must assign the program ID and the virtual ingress port.  The virtual ingress port assignment removes the need to think about the physical ingress port as a possible match field when managing any of the virtual program's tables that, when run natively, would match on the standard_metadata.ingress_port.  Virtual programs may not even be connected to any physical ports directly.  This virtual ingress port assignment therefore makes the HP4 virtual network easier to manage - we can rewire virtual programs without worrying about the physical ingress ports.

  The match fields should include standard_metadata and parsed representation fields.

- inbound virtual networking
  - tset_virtnet

  When a packet is handed over to another virtual program after having been processed by a virtual program already (we know this because the virtual egress port is non-zero), we need to copy the virtual egress port to the virtual ingress port and reset the virtual egress port in order to adopt the correct perspective of the current virtual program.

- recirculation cleanup
  - tset_recirc

  This subsystem may be handling an effect produced by virtual multicasting, depending on how virtual multicasting is handled.  It may be that the packet is cloned to egress and then recirculated and in the process we had to maintain the current program ID but track the destination program ID and we do the transfer and reset here as necessary.

  We need to fully design multicasting, to include virtual multicasting, and assess whether recirculation cleanup is required.  For example, we might be able to design virtual multicasting in a way that does away with the need for a temporary program ID field.

- parsing
  - tset_control
  - tset_inspect_XX_YY

  This subsystem handles parsing.  It provides the mechanisms for inspecting parsed representation values to determine whether a resubmit is required to extract more bytes.  At the end we are left with a header stack that contains the parsed representation.  

  We need to rename the tables, but apart from that, parsing is understood and functions as designed.

- parsed representation to HP4 metadata
  - tset_pr_XX_YY

  Once we have the parsed representation in a header stack, we copy all elements of the stack to a single metadata field to make arbitrary matching feasible.

- pipeline configuration
  - tset_pipeline

  This subsystem prepares HP4 to handle the virtual program's ingress pipeline.  Based on the program ID and the final parse_ctrl.state, we identify the tableID corresponding to the type of matching that must be performed first.  We also set the validbits bitmap indicating which headers are logically present in the parsed representation.

- match-action

  This subsystem handles the core functionality of the virtual program, performing equivalent matches and executing actions as chained instances of single primitives.

- egress_spec to port
  - t_link (rename: thp4_set_egress_spec)

  We need to handle the setting of the egress_spec.  Two options:
  - compiler interprets a modify_field, where the dest field is the egress_spec, as a modify_field where the dest field is meta_ctrl.virt_egress_port.  At some point we set the egress_spec to the ingress_port, just because the packet has to be handled by some port.  But then we need to look at the virt_egress_port and possibly change the egress_spec to a physical port that the virt_egress_port is mapped to.  Or we do nothing because the packet is destined for another virtual program.
  - compiler does not reinterpret the modify_field, with egress_spec as the dest field.  We get to the end of ingress and now we look at the egress_spec and set the virt_egress_port according to the egress_spec->virt_egress_port map, while the egress_spec is set to the ingress_port (because the packet has to be handled by some port).  Or we might instead just change the egress_spec because the packet should be sent out a physical port.     

Egress
- multicast
- checksum
- resize parsed representation

  We should skip this if the packet is going to another virtual program and not out a physical port.

- HP4 metadata to parsed representation

  We should skip this if the packet is going to another virtual program and not out a physical port.

- outbound virtual networking
- [egress filtering]

-----

HyPer4 Design

v0.1 Features
- 4 primitive types:
  -- modify_field
     --- target metadata <- standard metadata
     --- target metadata <- constant
     --- standard metadata <- target metadata
     --- standard metadata <- constant
  -- drop
  -- no_op
  -- truncate

v0.2 Features
- 2 Additional matching types: ternary, lpm
- 5 Additional primitive types:
  -- add_header
  -- copy_header
  -- remove_header
  -- push
  -- pop
- Python script to generate p4 code
  -- support user-specified max number of matches
  -- support user-specified max number of primitives to execute per match
  -- etc.

Outstanding Issues

- We have a potential problem with the initialization process.  Currently, we have a check_init table that has no entries and two possible default actions: init and no_op.  During normal operation the default action is no_op, and when the operator wants to trigger reinitialization, he changes the default action to init.  The problem is keeping initialization under control: we only want to execute initialization once, but it is triggered by the arrival of a packet in the dataplane, and while the switch initializes, other packets could arrive before we have a chance to revert the default action in the control plane.

How might we change this to ensure initialization happens only once?

We could use two registers and form a semaphore.  Assume both registers must be true in order to carry out initialization.  During normal operation, reg A is set to true and reg B is set to false.  Check_init default action is no_op until controller changes it to set_reg_B_true.  The first action taken by the intialization action is to set reg A to false.  The last actions taken by the intialization action is to set reg B to false and then set reg A to true.  Meanwhile, all subsequent packets should be held somehow (recirculated?) while reg B is true.

Double check this solution with existing semaphore implementations e.g. Peterson's Algorithm or Dekker's algorithm.


